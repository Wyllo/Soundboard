<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Classroom Soundboard</title>
<style>
  :root{
    --panel:#111827; --card:#1f2937; --muted:#94a3b8; --text:#e5e7eb;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    background:linear-gradient(180deg,#0b1222 0%, #0f172a 40%, #0c111c 100%);
    color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    display:flex;flex-direction:column;gap:12px;padding:10px
  }
  .top{
    display:flex;gap:8px;align-items:center;flex-wrap:wrap;
    background:rgba(17,24,39,.6);border:1px solid rgba(148,163,184,.18);
    backdrop-filter:blur(6px);padding:6px 8px;border-radius:12px
  }
  .title{font-weight:800}
  .sp{flex:1}
  .vol,.toggles{
    display:flex;align-items:center;gap:8px;background:rgba(31,41,55,.7);
    padding:6px 8px;border-radius:10px;border:1px solid rgba(148,163,184,.15)
  }
  .grid{display:grid;grid-template-columns:repeat(auto-fill, minmax(110px,1fr));gap:10px}
  @media (max-width:900px){.grid{grid-template-columns:repeat(auto-fill, minmax(100px,1fr))}}
  @media (max-width:640px){.grid{grid-template-columns:repeat(auto-fill, minmax(90px,1fr))}}
  body.compact .grid{grid-template-columns:repeat(auto-fill, minmax(80px,1fr)); gap:8px}

  .pad{
    position:relative;display:flex;flex-direction:column;justify-content:center;align-items:center;
    gap:4px;padding:12px;border-radius:14px;
    background:radial-gradient(120% 120% at 10% 10%, #22304a 0%, #111827 60%);
    border:1px solid rgba(148,163,184,.18);box-shadow:0 10px 24px rgba(0,0,0,.25);
    user-select:none;cursor:pointer;min-height:96px;text-align:center
  }
  body.compact .pad{min-height:72px;padding:8px;border-radius:12px}
  .pad .label{font-size:15px;font-weight:800;color:#ffffff;line-height:1.1}
  body.compact .pad .label{font-size:14px}
  .pad .hint{font-size:11px;color:var(--muted)}
  body.compact .pad .hint{display:none}

  .btn{
    appearance:none;border:0;background:var(--card);color:var(--text);
    padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:600;
    border:1px solid rgba(148,163,184,.18)
  }
  .toggle{display:flex;align-items:center;gap:6px;font-size:13px}
  .toggle input{accent-color:#a78bfa}
</style>
</head>
<body>
  <div class="top">
    <div class="title">üéõÔ∏è Classroom Soundboard</div>
    <div class="sp"></div>
    <div class="toggles">
      <label class="toggle"><input id="toggleCompact" type="checkbox"> Compact</label>
      <label class="toggle"><input id="toggleEmoji" type="checkbox"> Emoji</label>
    </div>
    <div class="vol">
      <span>Volume</span><input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.9" />
      <button id="stopAll" class="btn">Stop</button>
    </div>
  </div>

  <div class="grid" id="grid"></div>

<script>
(function(){
  // === Fichiers dans ./assets/ (minuscules) ===
  const ASSET_MAP = {
    bowl1:         "assets/bol1.mp3",
    bowl2:         "assets/bol2.mp3",
    later:         "assets/later.mp3",
    among:         "assets/among.mp3",
    applause:      "assets/applause.mp3",
    badum:         "assets/badum.mp3",
    crickets:      "assets/crickets.mp3",
    alone:         "assets/alone.mp3",
    nothingbeats:  "assets/nothingbeats.mp3",
    elevator:      "assets/elevator.mp3",
    laugh:         "assets/laugh.mp3",
    hero:          "assets/hero.mp3",
    sad:           "assets/sad.mp3",
    boom:          "assets/boom.mp3"
  };

  const EMOJI = {
    later:'‚è≠Ô∏è', among:'üë•', applause:'üëè', badum:'ü•Å', crickets:'ü¶ó', alone:'üßç',
    nothingbeats:'üèÜ', elevator:'üõó', laugh:'üòÇ', hero:'ü¶∏', sad:'üò¢', boom:'üí•'
  };

  // === Audio engine (lecture exclusive) ===
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const master = ctx.createGain(); master.gain.value = 0.9; master.connect(ctx.destination);
  const liveNodes = new Set();
  let currentSource = null;
  const now = ()=> ctx.currentTime;

  function addNode(n){
    if(!n) return;
    liveNodes.add(n);
    const onend = ()=> liveNodes.delete(n);
    try{ n.onended = onend }catch{}
  }

  function stopAllSources(){
    for(const n of Array.from(liveNodes)){
      try{ if(n.stop) n.stop(0) }catch{}
    }
    liveNodes.clear();
    currentSource = null;
  }

  // Synthesis fallbacks (si fichier manquant)
  function makeNoiseBuffer(len=2){
    const length=Math.floor(ctx.sampleRate*len);
    const buf=ctx.createBuffer(1,length,ctx.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<length;i++){ d[i]=(Math.random()*2-1); }
    return buf;
  }
  function drum(freq,dur,start){
    const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(freq,start);
    const g=ctx.createGain(); g.gain.setValueAtTime(0,start); g.gain.linearRampToValueAtTime(0.9,start+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001,start+dur); o.connect(g); g.connect(master);
    o.start(start); o.stop(start+dur); addNode(o);
  }
  function snare(start){
    const src=ctx.createBufferSource(); src.buffer=makeNoiseBuffer(0.3);
    const bp=ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1800; bp.Q.value=0.8;
    const g=ctx.createGain(); g.gain.setValueAtTime(0.001,start); g.gain.linearRampToValueAtTime(1.0,start+0.005);
    g.gain.exponentialRampToValueAtTime(0.0001,start+0.18); src.connect(bp); bp.connect(g); g.connect(master);
    src.start(start); src.stop(start+0.22); addNode(src);
  }
  function cymbal(start){
    const src=ctx.createBufferSource(); src.buffer=makeNoiseBuffer(0.8);
    const hp=ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=5500;
    const g=ctx.createGain(); g.gain.setValueAtTime(0.8,start); g.gain.exponentialRampToValueAtTime(0.0001,start+0.7);
    src.connect(hp); hp.connect(g); g.connect(master); src.start(start); src.stop(start+0.9); addNode(src);
  }
  function playRimshot(){ const t=now(); drum(110,0.18,t); drum(90,0.22,t+0.18); snare(t+0.36); cymbal(t+0.36); }
  function playApplause(){
    const dur=2.6; const src=ctx.createBufferSource(); src.buffer=makeNoiseBuffer(dur);
    const sh=ctx.createBiquadFilter(); sh.type='bandpass'; sh.frequency.value=1200; sh.Q.value=0.6;
    const env=ctx.createGain(); env.gain.setValueAtTime(0,now());
    const t0=now(); for(let i=0;i<13;i++){ const st=t0+i*0.18+(Math.random()*0.04);
      env.gain.linearRampToValueAtTime(0.0,st); env.gain.linearRampToValueAtTime(1.0,st+0.02);
      env.gain.linearRampToValueAtTime(0.2,st+0.10); }
    env.gain.linearRampToValueAtTime(0.0,t0+dur);
    src.connect(sh); sh.connect(env); env.connect(master);
    src.start(); addNode(src);
  }

  // UI pads (sans upload/liens)
  const grid=document.getElementById('grid');
  const pads=[
    {id:'bowl1',        label:'Bowl1'},
    {id:'bowl2',        label:'Bowl2'},
    {id:'later',        label:'Later',        hint:'Q', key:'q'},
    {id:'among',        label:'Among',        hint:'W', key:'w'},
    {id:'applause',     label:'Applause',     hint:'E', key:'e', synth:playApplause},
    {id:'badum',        label:'Badum',        hint:'R', key:'r', synth:playRimshot},
    {id:'crickets',     label:'Crickets',     hint:'A', key:'a'},
    {id:'alone',        label:'Alone',        hint:'S', key:'s'},
    {id:'nothingbeats', label:'Nothingbeats', hint:'D', key:'d'},
    {id:'elevator',     label:'Elevator',     hint:'F', key:'f'},
    {id:'laugh',        label:'Laugh',        hint:'Z', key:'z'},
    {id:'hero',         label:'Hero',         hint:'X', key:'x'},
    {id:'sad',          label:'Sad',          hint:'C', key:'c'},
    {id:'boom',         label:'Boom',         hint:'V', key:'v'}
  ];

  pads.forEach(p=>{
    const card=document.createElement('button'); card.className='pad'; card.type='button'; card.dataset.id=p.id;
    const lab=document.createElement('div'); lab.className='label'; lab.textContent=p.label;
    const hint=document.createElement('div'); hint.className='hint'; hint.textContent=p.hint ? `Touche : ${p.hint}` : '';
    card.appendChild(lab); card.appendChild(hint); grid.appendChild(card);
    card.addEventListener('click', async()=>{ await resume(); playPad(p.id); });
  });

  // Lecture d'un seul son √† la fois
  async function resume(){ if(ctx.state!=='running'){ await ctx.resume(); } }
  async function fetchToBuffer(url){
    const res=await fetch(url,{mode:'cors'});
    if(!res.ok) throw new Error('HTTP '+res.status);
    const ab=await res.arrayBuffer();
    return await ctx.decodeAudioData(ab);
  }

  const decoded = new Map(); // buffers pr√©charg√©s

  async function ensureLoaded(id){
    if(decoded.has(id)) return decoded.get(id);
    if(!(id in ASSET_MAP)) return null;
    try{
      const buf = await fetchToBuffer(ASSET_MAP[id]);
      decoded.set(id, buf);
      return buf;
    }catch(e){
      return null;
    }
  }

  async function playPad(id){
    const p = pads.find(x=>x.id===id);
    if(!p) return;
    // Stop tout ce qui joue d√©j√†
    stopAllSources();

    // Essaye le fichier; sinon, fallback synth si dispo
    const buf = await ensureLoaded(id);
    if(buf){
      const src=ctx.createBufferSource();
      src.buffer=buf;
      src.connect(master);
      src.start();
      currentSource = src;
      addNode(src);
      src.onended = ()=>{ if(currentSource===src) currentSource=null; liveNodes.delete(src); };
    }else if(p && p.synth){
      p.synth();
    }
  }

  // Raccourcis clavier (exclusifs aussi)
  const down=new Set();
  window.addEventListener('keydown', async e=>{
    if(down.has(e.code)) return;
    down.add(e.code);
    const k=e.key.toLowerCase();
    const found=pads.find(p=>(p.key && (p.key.toLowerCase()===k || p.key===e.code)));
    if(found){ e.preventDefault(); await resume(); playPad(found.id); }
  });
  window.addEventListener('keyup', e=> down.delete(e.code) );

  document.getElementById('masterVol').addEventListener('input', e=> master.gain.value=parseFloat(e.target.value) );
  document.getElementById('stopAll').addEventListener('click', stopAllSources);

  // Pr√©chargement silencieux
  (async function preload(){
    for(const id of Object.keys(ASSET_MAP)){
      ensureLoaded(id);
    }
  })();

  // === Compact & Emoji toggles ===
  const toggleCompact = document.getElementById('toggleCompact');
  const toggleEmoji   = document.getElementById('toggleEmoji');

  toggleCompact.addEventListener('change', ()=>{
    document.body.classList.toggle('compact', toggleCompact.checked);
  });

  toggleEmoji.addEventListener('change', ()=>{
    document.querySelectorAll('.pad').forEach(card=>{
      const id = card.dataset.id;
      const lab = card.querySelector('.label');
      if(toggleEmoji.checked){
        lab.textContent = EMOJI[id] || 'üéµ';
      } else {
        const p = pads.find(x=>x.id===id);
        lab.textContent = p ? p.label : id;
      }
    });
  });
})();
</script>
</body>
</html>
